<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 刘永杰的博客</title>
    <link>http://truthcode.github.io/posts/</link>
    <description>Recent content in Posts on 刘永杰的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Fri, 13 Mar 2020 15:09:33 +0800</lastBuildDate>
    
	<atom:link href="http://truthcode.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>关于Collection和Map的学习</title>
      <link>http://truthcode.github.io/posts/collection/</link>
      <pubDate>Fri, 13 Mar 2020 15:09:33 +0800</pubDate>
      
      <guid>http://truthcode.github.io/posts/collection/</guid>
      <description>今天写的是关于“Collection和Map的学习”： Part1 Collection接口   Set接口（无序）：     HashSet实现类
 不包含重复元素的集合 由hashcode来保证元素的唯一性    LinkedHashSet实现类
 按数据的插入顺序进行顺序储存 不包含重复元素 由hashcode来保证元素的唯一性    TreeSet实现类
 内部自然排序或者通过比较器Comparetor自定义排序 不包含重复元素      List接口（有序）：    ArrayList实现类 LinkedList实现类  Part2 Map接口   HashMap实现类
 此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。    TreeMap实现类
 内部自然排序或者通过比较器Comparetor自定义排序    总结   在使用时hashCode()和 equals()都需要被重写。
  Map的内容可以被当作一组key集合，一组value集合，或者一组Key-Value映射。通常返回为Set。务必务必特别小心使用由map返回的Set集合，通常对map的修改或者对Set的修改会互相影响。
  尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是面向对象的特性。</description>
    </item>
    
    <item>
      <title>关于Maven的学习以及如何解决包冲突</title>
      <link>http://truthcode.github.io/posts/maven/</link>
      <pubDate>Thu, 12 Mar 2020 22:52:33 +0800</pubDate>
      
      <guid>http://truthcode.github.io/posts/maven/</guid>
      <description>今天写的是关于“Maven的学习以及如何解决包冲突”： （举手）提出疑问四连：
 Maven是什么？ 为什么需要Maven？ Maven是如何运作的？ Maven出现包冲突又该如何解决？  Part1 Maven的介绍   Maven 到底是什么：    Maven 是专门用于构建和管理Java相关项目的工具 它包含了一个项目对象模型，一组标准集合，一个项目生命周期，一个依赖管理系统，和用来运行定义在生命周期阶段中插件目标的逻辑。   为什么要使用Maven    在开发项目时，项目中的一些功能依赖于其他项目中的某些类，为了维系这种依赖的关系，我们可以把项目依赖的类打包成jar包放在Library文件夹里，方便我们调用。   为什么要使用Maven以及使用Maven的好处：    使用Maven管理的Java 项目都有着相同的项目结构。有一个pom.xml 用于维护当前项目都用了哪些jar包；所有的java代码都放在 src/main/java 下面； 所有的测试代码都放在src/test/java 下面。 便于统一维护jar包   Maven工作方式：     Maven仓库分为本地仓库和中央仓库：
 本地仓库的作用是从中央仓库下载一个拥有相对完整的所有jar包的结合，放到本地仓库中，然后每次写项目，直接从本地仓库里调用，避免了每次生成新项目都要重新下载jar包的麻烦。本地仓库默认的位置是处于C:\Users\Administrator\.m2\repository 但我们可以在IDEA中进行修改。  中央仓库是由Maven自己维护，里面有大量的常用类库，并包含了世界上大部分流行的开源项目构件。如果本地仓库中没有对应的jar包，默认从中央仓库下载。中央仓库默认地址是http://repo1.maven.org/maven2 ,但由于国内有墙的原因，所以往往下载速度都很慢，可以在apache-maven-3.6.3\conf\settings.xml文件中修改镜像仓库。     Maven如何在仓库中定位一个jar包：
 在pom.xml文件通过groupId（包名）、artifactId（项目名）、version（版本号）三个坐标进行定位     Part2 解决Maven使用中的错误和包冲突问题   如何在中央仓库去寻找一个缺失的jar包：  假如我们缺少的是下图中的jar包  在网页搜索我们既能轻松进入[中央仓库]（https://mvnrepository.</description>
    </item>
    
    <item>
      <title>如何用 hugo 搭建个人博客</title>
      <link>http://truthcode.github.io/posts/create-hugo/</link>
      <pubDate>Thu, 12 Mar 2020 22:52:33 +0800</pubDate>
      
      <guid>http://truthcode.github.io/posts/create-hugo/</guid>
      <description>今天写的第一篇博客是关于“如何用 hugo 搭建个人博客”：  HUGO的快速设置八部曲 GitHub的新建username.github.io仓库和上传public文件夹  Part 1 HUGO的搭建 （下面例子以Windows为例）   HUGOv0.67.0版本，下载对应自己电脑操作平台的压缩包，解压后得到hugo.exe。
  HUGO添加环境变量并验证安装    把HUGO添加到环境变量中,添加成功后命令行输入hugo version 验证HUGO是否安装成功，如 Hugo Static Site Generator v0.67.0-7F1DA3EF windows/amd64 BuildDate: 2020-03-09T20:35:55Z 恭喜你，可以进入下一步操作了。   创建username.github.io-creator目录    hugo new site username.github.io-creator（username为你的GITHUB用户名），生成目录文件夹后，cd 文件名进入文件目录。   创建git本地仓库并添加主题    git init初始化一个空的git本地仓库，然后输入 git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke 回车执行再次输入 echo &#39;theme = &amp;quot;ananke&amp;quot;&#39; &amp;gt;&amp;gt; config.toml完成添加主题的操作。   创建.md文本并添加内容    hugo new posts/自己取的文章名.</description>
    </item>
    
    <item>
      <title>开博大吉</title>
      <link>http://truthcode.github.io/posts/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</link>
      <pubDate>Wed, 11 Mar 2020 22:52:33 +0800</pubDate>
      
      <guid>http://truthcode.github.io/posts/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</guid>
      <description>我的博客开通了！希望我能够写出好文章给大家看。</description>
    </item>
    
    <item>
      <title>关于ThreadPoolExecutor构造函数各参数意义</title>
      <link>http://truthcode.github.io/posts/threadpoolexecutor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://truthcode.github.io/posts/threadpoolexecutor/</guid>
      <description>关于ThreadPoolExecutor构造函数各参数意义”： 参数意义    corePoolSize。核心线程池大小。这个参数是否生效取决于allowCoreThreadTimeOut变量的值，该变量默认是false，即对于核心线程没有超时限制，所以这种情况下，corePoolSize参数是起效的。如果allowCoreThreadTimeOut为true，那么核心线程允许超时，并且超时时间就是keepAliveTime参数和unit共同决定的值，这种情况下，如果线程池长时间空闲的话最终存活的线程会变为0，也即corePoolSize参数失效。
  maximumPoolSize。线程池中最大的存活线程数。这个参数比较好理解，对于超出corePoolSize部分的线程，无论allowCoreThreadTimeOut变量的值是true还是false，都会超时，超时时间由keepAliveTime和unit两个参数算出。
   keepAliveTime。超时时间。
  unit。超时时间的单位，秒，毫秒，微秒，纳秒等，与keepAliveTime参数共同决定超时时间。
  workQueue。当调用execute方法时，如果线程池中没有空闲的可用线程，那么就会把这个Runnable对象放到该队列中。这个参数必须是一个实现BlockingQueue接口的阻塞队列，因为要保证线程安全。有一个要注意的点是，只有在调用execute方法是，才会向这个队列中添加任务，那么对于submit方法呢，难道submit方法提交任务时如果没有可用的线程就直接扔掉吗？当然不是，看一下AbstractExecutorService类中submit方法实现，其实submit方法只是把传进来的Runnable对象或Callable对象包装成一个新的Runnable对象，然后调用execute方法，并将包装后的FutureTask对象作为一个Future引用返回给调用者。Future的阻塞特性实际是在FutureTask中实现的。
  threadFactory。线程工厂类。用于在需要的时候生成新的线程。默认实现是Executors.defaultThreadFactory()，即new 一个Thread对象，并设置线程名称，daemon等属性。
   handler。这个参数的作用是当提交任务时既没有空闲线程，任务队列也满了，这时候就会调用handler的rejectedExecution方法。默认的实现是抛出一个RejectedExecutionException异常。
  </description>
    </item>
    
  </channel>
</rss>